From bfcc625b2f048cd7c5c79746ef5fc1b348765fe3 Mon Sep 17 00:00:00 2001
From: Aurelio Colosimo <aurelio@aureliocolosimo.it>
Date: Thu, 7 May 2015 15:03:52 +0200
Subject: [PATCH 16/83] MCUIO adc driver copied from kernel 3.3.8

Files were copied from Linino kernel_3.3.8 master branch

git repository: git@github.com/linino/kernel_3.3.8
git commit: a20da43584

Signed-off-by: Aurelio Colosimo <aurelio@aureliocolosimo.it>
---
 drivers/iio/adc/Kconfig     |   7 ++
 drivers/iio/adc/Makefile    |   1 +
 drivers/iio/adc/mcuio_adc.c | 231 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 239 insertions(+)
 create mode 100644 drivers/iio/adc/mcuio_adc.c

diff --git a/drivers/iio/adc/Kconfig b/drivers/iio/adc/Kconfig
index 88bdc8f..56d6fab 100644
--- a/drivers/iio/adc/Kconfig
+++ b/drivers/iio/adc/Kconfig
@@ -299,4 +299,11 @@ config XILINX_XADC
 	  The driver can also be build as a module. If so, the module will be called
 	  xilinx-xadc.
 
+config MCUIO_ADC
+	tristate "mcuio ADC driver"
+	depends on MCUIO
+	default y
+	help
+	  Adds a driver mcuio ADC inputs (experimental)
+
 endmenu
diff --git a/drivers/iio/adc/Makefile b/drivers/iio/adc/Makefile
index cb88a6a..16ed4c5 100644
--- a/drivers/iio/adc/Makefile
+++ b/drivers/iio/adc/Makefile
@@ -30,5 +30,6 @@ obj-$(CONFIG_TWL4030_MADC) += twl4030-madc.o
 obj-$(CONFIG_TWL6030_GPADC) += twl6030-gpadc.o
 obj-$(CONFIG_VF610_ADC) += vf610_adc.o
 obj-$(CONFIG_VIPERBOARD_ADC) += viperboard_adc.o
+obj-$(CONFIG_MCUIO_ADC) += mcuio_adc.o
 xilinx-xadc-y := xilinx-xadc-core.o xilinx-xadc-events.o
 obj-$(CONFIG_XILINX_XADC) += xilinx-xadc.o
diff --git a/drivers/iio/adc/mcuio_adc.c b/drivers/iio/adc/mcuio_adc.c
new file mode 100644
index 0000000..1088cf7
--- /dev/null
+++ b/drivers/iio/adc/mcuio_adc.c
@@ -0,0 +1,231 @@
+/*
+ * Copyright 2014 Dog Hunter SA
+ * Author: Aurelio Colosimo <aurelio@aureliocolosimo.it>
+ *
+ * GNU GPLv2 or later
+ */
+
+/* MCUIO IIO driver for ADC inputs */
+
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/iio/iio.h>
+#include <linux/regmap.h>
+#include <linux/mcuio.h>
+#include <linux/mcuio_ids.h>
+#include <linux/mcuio-proto.h>
+
+#define MCUIO_ADC_FLAG_SIGNED	(1 << 0)
+
+struct mcuio_adc {
+	struct regmap *map;
+	u32 vres_uv;
+};
+
+static const struct regmap_config mcuio_adc_regmap_config = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.max_register = 0xffc,
+	.cache_type = REGCACHE_NONE,
+};
+
+static int mcuio_adc_read_raw(struct iio_dev *idev,
+			    struct iio_chan_spec const *ch, int *val,
+			    int *shift, long mask)
+{
+	struct mcuio_adc *adc = iio_priv(idev);
+	int ret = -EINVAL;
+	u32 _val = 0;
+	u32 addr;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		addr = 0x040 * (ch->address + 1) + 0x0c;
+		break;
+
+	case IIO_CHAN_INFO_SCALE:
+		addr = 0x040 * (ch->address + 1) + 0x08;
+		break;
+
+	default:
+		goto out;
+	}
+
+	ret = regmap_read(adc->map, addr, &_val);
+
+	if (ret < 0) {
+		dev_err(&idev->dev,
+			"failed to read mcuio addr %03x\n", addr);
+		goto out;
+	}
+
+	*val = _val;
+	ret = IIO_VAL_INT;
+
+out:
+	return ret;
+}
+
+static const struct iio_info mcuio_adc_info = {
+	.read_raw = mcuio_adc_read_raw,
+	.driver_module = THIS_MODULE,
+};
+
+
+ssize_t mcuio_adc_enable_read(struct iio_dev *idev, uintptr_t private,
+			struct iio_chan_spec const *channel, char *buf)
+{
+	u32 en = 0;
+	struct mcuio_adc *adc = iio_priv(idev);
+	regmap_read(adc->map, 0x14, &en);
+	return snprintf(buf, PAGE_SIZE, "%d\n", en & 0x1 ? 1 : 0);
+}
+
+ssize_t mcuio_adc_enable_write(struct iio_dev *idev, uintptr_t private,
+			 struct iio_chan_spec const *channel, const char *buf,
+			 size_t len)
+{
+	uint32_t _en, en_new;
+	struct mcuio_adc *adc = iio_priv(idev);
+	regmap_read(adc->map, 0x14, &_en);
+	en_new = (buf[0] - '0') & 0x1;
+	regmap_write(adc->map, 0x14, (_en & ~0x1) | en_new);
+	return len;
+}
+
+static struct iio_chan_spec_ext_info iio_chan_spec_enable = {
+	.name = "enable",
+	.shared = IIO_SHARED_BY_ALL,
+	.read = mcuio_adc_enable_read,
+	.write = mcuio_adc_enable_write,
+};
+
+static int mcuio_adc_probe(struct mcuio_device *mdev)
+{
+	struct iio_dev *idev;
+	struct mcuio_adc *adc;
+	int ret = 0;
+	u32 flags;
+	struct iio_chan_spec *ch;
+	int i;
+	char *lbls;
+
+	idev = devm_iio_device_alloc(&mdev->dev, sizeof(*adc));
+	if (!idev)
+		return -ENOMEM;
+
+	dev_set_drvdata(&mdev->dev, idev);
+
+	adc = iio_priv(idev);
+
+	adc->map = devm_regmap_init_mcuio(mdev, &mcuio_adc_regmap_config);
+
+	if (IS_ERR(adc->map)) {
+		dev_err(&mdev->dev, "cannot setup regmap for device\n");
+		return PTR_ERR(adc->map);
+	}
+
+	idev->dev.parent = &mdev->dev;
+	idev->name = "mcuio-adc";
+	idev->modes = INDIO_DIRECT_MODE;
+	idev->info = &mcuio_adc_info;
+
+	pr_info("mcuio adc is %u:%u:%u\n",
+		 mdev->bus, mdev->device, mdev->fn);
+
+	/* Read nchannels */
+	ret = regmap_read(adc->map, 0x008, &idev->num_channels);
+	if (ret < 0)
+		return ret;
+	dev_info(&mdev->dev, "%d input channels detected\n",
+		 idev->num_channels);
+
+	/* Allocate mem for channels info */
+	ch = devm_kzalloc(&mdev->dev,
+			idev->num_channels * sizeof(struct iio_chan_spec),
+			GFP_KERNEL);
+
+	if (!ch)
+		return -ENOMEM;
+
+	/* Allocate mem for labels */
+	lbls = devm_kzalloc(&mdev->dev,
+			idev->num_channels * 8, GFP_KERNEL);
+	if (!lbls)
+		return -ENOMEM;
+
+	/* Initialize channels info */
+	for (i = 0; i < idev->num_channels; i++) {
+		ch[i].type = IIO_VOLTAGE;
+		ch[i].indexed = 1;
+		ch[i].channel = ch[i].address = i;
+		ch[i].info_mask_separate =
+			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_SCALE);
+
+		/* read flags */
+		regmap_read(adc->map, 0x040 * (i + 1) + 0x04, &flags);
+		ch[i].differential = flags & MCUIO_ADC_FLAG_SIGNED ? 1 : 0;
+		ch[i].indexed = ch[i].differential ? 1 : 0;
+
+		if (i == 0)
+			ch[i].ext_info = &iio_chan_spec_enable;
+
+		/* read label */
+		regmap_read(adc->map, 0x040 * (i + 1), (u32*)&lbls[i * 8]);
+		ch[i].extend_name = &lbls[i * 8];
+		dev_dbg(&mdev->dev, "found adc %u: %s\n", i, &lbls[i * 8]);
+	}
+
+	idev->channels = ch;
+
+	ret = iio_device_register(idev);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mcuio_adc_remove(struct mcuio_device *mdev)
+{
+	struct iio_dev *idev = dev_get_drvdata(&mdev->dev);
+	iio_device_unregister(idev);
+	return 0;
+}
+
+static const struct mcuio_device_id mcuio_adc_drv_ids[] = {
+	{
+		.class = MCUIO_CLASS_ADC,
+		.class_mask = 0xffff,
+	},
+	/* Terminator */
+	{
+		.device = MCUIO_NO_DEVICE,
+		.class = MCUIO_CLASS_UNDEFINED,
+	},
+};
+
+static struct mcuio_driver mcuio_adc_driver = {
+	.driver = {
+		.name = "mcuio-adc",
+	},
+	.id_table = mcuio_adc_drv_ids,
+	.probe = mcuio_adc_probe,
+	.remove = mcuio_adc_remove,
+};
+
+static int __init mcuio_adc_init(void)
+{
+	return mcuio_driver_register(&mcuio_adc_driver, THIS_MODULE);
+}
+
+static void __exit mcuio_adc_exit(void)
+{
+	mcuio_driver_unregister(&mcuio_adc_driver);
+}
+
+subsys_initcall(mcuio_adc_init);
+module_exit(mcuio_adc_exit);
+
+MODULE_AUTHOR("Aurelio Colosimo <aurelio@aureliocolosimo.it>");
+MODULE_DESCRIPTION("MCUIO adc driver");
+MODULE_LICENSE("GPL v2");
-- 
2.10.1

