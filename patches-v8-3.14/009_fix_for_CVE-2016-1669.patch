From 945e1f1b3351744c7d691c7fb976b36fd3a7c5e9 Mon Sep 17 00:00:00 2001
From: Myles Borins <mborins@us.ibm.com>
Date: Thu, 2 Jun 2016 18:11:28 +0200
Subject: [PATCH] deps: backport 3a9bfec from v8 upstream

Some of the logic from `zone.cc` is found in `zone-inl.h` in this
release stream.

Original commit message:

  Fix overflow issue in Zone::New

  When requesting a large allocation near the end of the address space,
  the computation could overflow and erroneously *not* grow the Zone
  as required.

	BUG=chromium:606115
	LOG=y

  Review-Url: https://codereview.chromium.org/1930873002
  Cr-Commit-Position: refs/heads/master@{#35903}

PR-URL: https://github.com/nodejs/node-private/pull/43
Reviewed-By: Ben Noordhuis <info@bnoordhuis.nl>
Reviewed-By: Rod Vagg <rod@vagg.org>

Signed-off-by: Jeroen Ooms <jeroenooms@gmail.com>
---
 src/zone-inl.h | 5 ++++-
 src/zone.cc    | 5 ++++-
 2 files changed, 8 insertions(+), 2 deletions(-)

diff --git a/src/zone-inl.h b/src/zone-inl.h
index e312b20..076556e 100644
--- a/src/zone-inl.h
+++ b/src/zone-inl.h
@@ -55,7 +55,10 @@ inline void* Zone::New(int size) {
   // Check if the requested size is available without expanding.
   Address result = position_;
 
-  if (size > limit_ - position_) {
+  const uintptr_t limit = reinterpret_cast<uintptr_t>(limit_);
+  const uintptr_t position = reinterpret_cast<uintptr_t>(position_);
+  // position_ > limit_ can be true after the alignment correction above.
+  if (limit < position || size > limit - position) {
      result = NewExpand(size);
   } else {
      position_ += size;
diff --git a/src/zone.cc b/src/zone.cc
index c12978f..82b3835 100644
--- a/src/zone.cc
+++ b/src/zone.cc
@@ -168,7 +168,10 @@ Address Zone::NewExpand(int size) {
   // Make sure the requested size is already properly aligned and that
   // there isn't enough room in the Zone to satisfy the request.
   ASSERT(size == RoundDown(size, kAlignment));
-  ASSERT(size > limit_ - position_);
+  ASSERT(limit_ < position_ ||
+         reinterpret_cast<uintptr_t>(limit_) -
+                 reinterpret_cast<uintptr_t>(position_) <
+             size);
 
   // Compute the new segment size. We use a 'high water mark'
   // strategy, where we increase the segment size every time we expand
